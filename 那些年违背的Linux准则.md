## Linux设计准则 ##

**映射**

>"It is not perfect, perfect forever uncommon. Perhaps, perfect is in sight." 

在Tron的世界，库鲁在赶尽杀绝同分异构体，统一数位DNA后，始终无法达到完美乌托邦。

> 2002年10月1日，滚石乐队专辑Forty Licks败给了猫王的热门曲目精选集

滚石乐队的作品只有摇滚一种风格，也没有任何与第三方一起创作的歌曲，天赋只能用“闭源”的方式来体现。猫王深谙重用之道，借鉴别人的音乐，作品风格多变，借助他作品的大热，许多人也从中分一杯羹。

> 拉丁语落寞，英语国际化

拉丁语曾经拥有英语一样的地位，随着东罗马帝国被日耳曼民族的入侵，教会禁止蛮族修改玷污他们的语言，缩小宣传，最终归隐在宁静的教堂。英语兼容并包各种文化，完成了语言的本职工作——连接。


**创世**

在Linux出现之前，借鉴他人编写的软件已成为相当普遍的做法。Richard M. Stallman在GNU公共授权协议GPL下确立了这一思想，基本保证了软件的源代码可以自由提供给任何想要得到他的人。

1990年的12月Linus Torvalds发现微软的操作系统并没有充分利用英特尔386电脑，决定自行编写一个内核，加入到GNU计划中，允许用户修改，自由传递。他为极客创造了一个自由的乌托邦。

```
The Grid
A digital frontier.
I tried to picture clusters of information
as they traveled through the computer.
What do they look like Ships, motorcycles.
With the circuits like freeways.
I kept dreaming of a world I thought I'd never see.
And then, one day... I got in.
```

今天Linux开发者数量早已达到了几百万之多，庞大的开发社区必须通过一些规章制度进行管理，以满足代码的层级分支管理。

**律法**

大教堂的律法是高阶祭祀决定的，集市不同，其规则是大众提出集成的。终于，一个名叫的Mike Gancarz的“以赛亚”出现了，他提出了Linux and the Unix Philosophy。

- 准则1：小即是美

     任何程序的大部分代码实际上都没在执行它所宣称的功能。就自身而言，小程序做的事情并不多。只实现一两个功能。但如果结合在一起，就能体现它们的真正力量。整体功能大于各个局部功能的简单相加。大型复杂任务迎刃而解。除此之外，小程序易于维护和理解，算法没有那么复杂；使用系统资源也很少；最重要的是可以相互结合移植，组件新的功能，在Linux系统中各个命令加管道连接的做法就是明显的范例。

     软件工程师经常会不由自主成为“功能控”，一开始确实只想编写简单的应用程序，完成后他的创新精神会慢慢占据上风，促使程序成为一个大杂烩，更有甚者，影响原有规划。

     应该集中精力去解决当前的任务，如果无法让程序只做好一件事，很可能并不理解自己正在解决的问题。

- 准则2：尽快建立原型

     人类创造的三个系统

     1.在背水一战的情况下，人类创造了第一个系统:在巨大的交付压力下，开发人员构思着系统，但是他没有足够的时间将构思实现。他计划将一些功能放到后续版本去完成，但是嘲讽的是，后续版本你也不会怎么进行修改。于是，莫名的激情亦或是热情激发着单枪匹马或者一小群自诩天才的人投身其中。一个精简丑陋的软件诞生了！在完成任务的同事，人民陷入了天马行空的思考，罗列了一大推新的需求等待着2.0。
     
     2.砖家们设计了怪胎般的第二个系统：砖家们进入了，因为上层发现程序的商业化价值，重金请来了诸多架构师。砖家们往往痛批第一个系统的垃圾，声称只要按他的设计可以做得更好。这是一种NIH的以为，“非我发明”综合征的体现。于是，更大规模的团队开始了工作，按照砖家的设计开始了业务的堆砌。“第一个系统”是精简的，“第二个系统”像是步履维艰的巨人。但是诸多功能的实现，销售人员在商场上披荆斩棘，而那些买单的用户往往不知道基本90%的功能用不到。
	
     3.第二个系统自我重构成了第三个系统：慢慢地，人们发现，资源的消耗，功能点的冗余，再设计的困难让团队精疲力尽。“令你别无他求”的系统不过是众多系统的一个。第三个系统要出现了，它往往被赋予新的名字，加以新的期待，并且重新回到第一个系统的需求设计。更重要的是，开发者有足够的时间让第二系统顶着，将第三系统做好。
     
     桌面程序X10（第一系统）到X Window System(第二系统）最终产生X11(第三系统）是很好的例子。

- 准则3：舍高效率而取可移植性

     程序员在开发中面临中高效率和可移植性的抉择。高效率的软件往往会导致代码不可抑制，而可移植的代码往往让软件的性能不那么尽如人意。

     摩尔定律让可移植软件比高效率软件更有价值，开发人员不用花过多的时间去优化，计算机的处理能力飞速翻倍增长，只要能确能顺利移植到高性能平台即可，剩下的就是游说老板们换机器。

- 准则4：充分利用软件的杠杆效应

     良好的程序员编写优秀的代码，优秀的程序员借用优秀的代码。这里不得不提及NIH。

     NIH综合征：软件开发人员常有的病，在查看别人编写的软件时，他认为自己完全可以做得更好，业务他真的可以更好的完成工作，但他不知道当时面临的限制。这种狂妄自大的行径说明此人并无兴趣去理解维护他人的工作成功，这是自私自利的做法，还浪费了大量宝贵的时间。

     在Linux下,shell脚本通过调用本地程序、解释程序和其他shell脚本来执行任务。用shell来替代C去完成执行时间少编译时间长的任务，付出了较少的努力，收益高于多行代码，并且易于移植和重用，Linux中软件杠杆效应。

- 准则5：让每一个程序成为过滤器

     所有的程序都以某种形式接收数据作为它的输入，并产生数据作为出去。计算机无法创建数据，只有人类才能控制数据的流向，而程序只是一个过滤器，转换了数据的形式。软件设计师往往在设计需求的时候预测和引导用户的使用方法，然而事与愿违，技术支持部门永远想不到用户会超出软件原本设计意图去做各种令人意想不到的尝试。

     如果用过滤器的思维去设计程序，在开发过程中就容易避免对用户操作进行控制，你只会考虑数据最终可能会到达的地方。并且会设计小而美的程序，牺牲程序的“引导性”，让用户的入口只有一个，其余过滤链中各组件的user=program


- 准则6：寻找90%的解决方案

     顺丰快递可以将你的包裹一天送到，而邮政包裹确无法实现这个要求。因为商业化服务公司只提供了90%的解决方案。完成90%往往比100%来得更容易，就拿顺丰举例，一天内到货的地区往往是交通发达包裹量大的地区，而邮政包裹可以达到中国各地，他们做了100%的服务。

     软件开发者大部分都是完美主义者，我们需要故意忽略那些费时费力的需要，去解决大部分问题而已。如果按照严格定义，软件是不可能完成的，没有人能开发出一个100%的系统。Linux也同样，它的晦涩难懂并非要求人人都懂，也不会解决100%的问题，而是用自我的特点去吸引信徒。


**未来**

高性能计算和云基础架构以及移动端的发展将Linux占有率达到了前所未有的，微软转变了态度：

> 1.CEO Satya Nadella透露微软Azure上运行 Linux 操作系统的占比已经达到了 20%

> 2.Scott Guthrie宣布了ASP.NET 5。而它所带来的最大变化，就是自诞生15年来首次推出了支持跨平台的开源版本。支持在Windows、Mac、以及Linux平台上运行。

云计算大行其道的今天，微软的行为更符合一个商人的思维，立场和信仰只属于极客，商业竞争下市场是第一要素。优势方永远想以封闭提供专业化服务来垄断行业，劣势方以开源“哲学”来博得眼球。

不同的产品总能匹配适合的用户，抛开舆论和习惯，博采众长。

